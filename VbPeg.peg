#
# PE Grammar for PE Grammars
# 
# Adapted from [1] by Ian Piumarta <first-name at last-name point com>.
# Actions translated to VB6 by wqweto@gmail.com.
# 
# Local modifications to support:
#  - VB6 code in '{ ... }' copied verbatim to output as 'semantic action'
#  - input consumed between '<' and '>' is 'Mid$(ctx.Contents, lOffset, lSize)' in semantic actions
# 
# [1] Bryan Ford.  "Parsing Expression Grammars: A Recognition-Based Syntactic
#     Foundation."  Symposium on Principles of Programming Languages,
#     January 14--16, 2004, Venice, Italy.
#

# Hierarchical syntax

Grammar         <- Spacing (Setting / Rule)+ 
                                             (EndOfFile /              &{ AppendError("Expected rule or setting") }
                                             )

Rule            <- Identifier                                           {   With .UserData
                                                                                lNode = .BeginRule(.FindRule(lOffset, Mid$(ctx.Contents, lOffset, lSize)))
                                                                                If .RuleExpression(lNode) <> 0 Then
                                                                                    ConsoleError "Rule '%1' redefined" & vbCrLf, Mid$(ctx.Contents, lOffset, lSize)
                                                                                End If
                                                                                .Push lNode
                                                                            End With }
                                                                       &{ ClearErrors() And SetUserDataTag($$text) }
                              (Literal                                  { With .UserData: .RuleDescription(.Top) = Mid$(ctx.Contents, lOffset, lSize): End With }
                              )?       Assign 
                                              (Expression               { With .UserData: lNode = .Pop(): .RuleExpression(.Pop()) = lNode: End With }
                                               /                       &{ AppendError("Invalid definition for rule '" & .UserData.Tag & "'") }
                                              )           SEMI?
Expression      <- ChoiceExpr
ChoiceExpr      <- SequenceExpr (Choice SequenceExpr                    { With .UserData: lNode = .Pop(): .Push .AppendChild(.MakeAlternate(lOffset, .Pop), lNode): End With }
                                )*
SequenceExpr    <- ErrorExpr (ErrorExpr                                 { With .UserData: lNode = .Pop(): .Push .AppendSequence(.MakeSequence(lOffset, .Pop), lNode): End With }
                             )*
                 /                                                      { With .UserData: .Push .MakePredicate(lOffset, "1"): End With }
ErrorExpr       <- VariableExpr CARET                                  &{ ClearErrors() }
                                      (Identifier                       { With .UserData: .Push .AppendChild(.MakeAlternate(lOffset, .Pop), .MakeErrorReference(lOffset, Mid$(ctx.Contents, lOffset, lSize))): End With }
                                       / Literal                        { With .UserData: .Push .AppendChild(.MakeAlternate(lOffset, .Pop), .MakeErrorString(lOffset, Mid$(ctx.Contents, lOffset, lSize))): End With }
                                       /                               &{ AppendError("Expected rule or literal for error label") }
                                      )
                 / VariableExpr !CARET
VariableExpr    <- Identifier                                           { With .UserData: .Push .MakeVariable(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                              COLON PrefixExpr                          { With .UserData: .Push .SetVariable(lOffset, .Pop, .Pop): End With }
                 / PrefixExpr
PrefixExpr      <- AND Action                                           { With .UserData: .Push .MakePredicate(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / AND SuffixExpr                                       { With .UserData: .Push .MakePeekFor(lOffset, .Pop): End With }
                 / NOT SuffixExpr                                       { With .UserData: .Push .MakePeekNot(lOffset, .Pop): End With }
                 /     SuffixExpr
SuffixExpr      <- PrimaryExpr (QUESTION                                { With .UserData: .Push .MakeQuery(lOffset, .Pop): End With }
                                / STAR                                  { With .UserData: .Push .MakeStar(lOffset, .Pop): End With }
                                / PLUS                                  { With .UserData: .Push .MakePlus(lOffset, .Pop): End With }
                               )?
PrimaryExpr     <- Identifier !(LiteralNC? Assign)                      { With .UserData: .Push .MakeReference(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / OPEN                                                &{ ClearErrors() }
                        (Expression CLOSE
                         /                                             &{ AppendError("Invalid expression") }
                        )
                 / LiteralNoSpace                                       { With .UserData: .Push .MakeString(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                    (IgnoreCase                                         { With .UserData: .SetIgnoreCase .Top, (Mid$(ctx.Contents, lOffset, lSize) = "i"): End With }
                    )? Spacing
                 / ClassNoSpace                                         { With .UserData: .Push .MakeClass(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                    (IgnoreCase                                         { With .UserData: .SetIgnoreCase .Top, (Mid$(ctx.Contents, lOffset, lSize) = "i"): End With }
                    )? Spacing
                 / DOT                                                  { With .UserData: .Push .MakeDot(lOffset): End With }
                 / Action                                               { With .UserData: .Push .MakeAction(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / BEGIN                                                { With .UserData: .Push .MakePredicate(lOffset, "YY_BEGIN"): End With }
                 / END                                                  { With .UserData: .Push .MakePredicate(lOffset, "YY_END"): End With }

Setting         <- SettingName                                          { With .UserData: .Push .MakeString(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                                                                       &{ ClearErrors() And SetUserDataTag($$text) }
                               (SettingValue                            { With .UserData: .AppendSetting .Pop, Mid$(ctx.Contents, lOffset, lSize): End With }
                                /                                      &{ AppendError("Invalid value for setting '" & .UserData.Tag & "'") }
                               )
SettingName     <- AT (Identifier / Literal / EMPTY)                   
SettingValue    <- (Identifier / Literal / Action) SEMI?                          
                 
# Lexical rules

Identifier      <- < IdentStart IdentCont* > Spacing                    { }
IdentStart      <- [a-zA-Z_\-]
IdentCont       <- IdentStart / [0-9]
Literal         <- LiteralNoSpace Spacing
LiteralNoSpace  <- ['] < (!['] Char )* > [']                            { }
                 / ["] < (!["] Char )* > ["]                            { }
LiteralNC       <- ['] (!['] Char )* ['] Spacing                        # Non-capture version
                 / ["] (!["] Char )* ["] Spacing
IgnoreCase      <- < [si] >                                             { }
ClassNoSpace    <- '[' < (!']' Range)* > ']'                            { }
Range           <- Char '-' !']' Char / Char
Char            <- '\\' [abefnrtv'"\[\]\\]
                 / '\\' [0-3][0-7][0-7]
                 / '\\' [0-7][0-7]?
                 / '\\' '-'
                 / !'\\' .
LEFTARROW       <- '<-' Spacing
SLASH           <- '/' !'/' Spacing
AND             <- '&' Spacing
NOT             <- '!' Spacing
QUESTION        <- '?' Spacing
STAR            <- '*' Spacing
PLUS            <- '+' Spacing
OPEN            <- '(' Spacing
CLOSE           <- ')' Spacing
DOT             <- '.' Spacing
EMPTY           <- < '' > Spacing                                       { }
Spacing         <- (Space / Comment)*
Comment         <- ('#' / '//') (!EndOfLine .)* EndOfLine
Space           <- ' ' / '\t' / EndOfLine
EndOfLine       <- '\r\n' / '\n' / '\r'
EndOfFile       <- !.

Action          <- '{' EndOfLine* < ([^{}] / ActionNC)* > '}' Spacing   { }
ActionNC        <- '{' ([^{}] / ActionNC)* '}' Spacing                  # Non-capture version
BEGIN           <- '<' Spacing
END             <- '>' Spacing

Assign          <- LEFTARROW / EQUAL
Choice          <- SLASH / BAR
EQUAL           <- '=' Spacing
BAR             <- '|' Spacing
COLON           <- ':' Spacing
SEMI            <- ';' Spacing
AT              <- '@' Spacing
CARET           <- '^' Spacing

@members {
    Errors              As Collection
}

@prolog {
    Dim lNode           As Long
    
    With ctx
}
@epilog {
    End With
}

@{
Private Function ClearErrors() As Boolean
    Dim lIdx            As Long
    
    If Not ctx.Errors Is Nothing Then
        For lIdx = ctx.Errors.Count To 1 Step -1
            If ctx.Errors.Item(lIdx)(1) <= ctx.BufPos Then
                ctx.Errors.Remove lIdx
            End If
        Next
        If ctx.Errors.Count = 0 Then
            Set ctx.Errors = Nothing
        End If
    End If
    ClearErrors = True
End Function

Private Function AppendError(sText As String) As Boolean
    If ctx.Errors Is Nothing Then
        Set ctx.Errors = New Collection
    End If
    ctx.Errors.Add Array(sText, ctx.BufPos)
End Function

Private Function SetUserDataTag(sText As String) As Boolean
    ctx.UserData.Tag = sText
    SetUserDataTag = True
End Function

Public Function GetParseErrors() As Collection
    Set GetParseErrors = ctx.Errors
End Function
}