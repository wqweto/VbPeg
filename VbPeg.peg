#
# PE Grammar for PE Grammars
# 
# Adapted from [1] by Ian Piumarta <first-name at last-name point com>.
# Actions translated to VB6 by wqweto@gmail.com.
# 
# Local modifications to support:
#  - VB6 code in '{ ... }' copied verbatim to output as 'semantic action'
#  - input consumed between '<' and '>' is 'Mid$(ctx.Contents, lOffset, lSize)' in semantic actions
# 
# [1] Bryan Ford.  "Parsing Expression Grammars: A Recognition-Based Syntactic
#     Foundation."  Symposium on Principles of Programming Languages,
#     January 14--16, 2004, Venice, Italy.
#

# Hierarchical syntax

Grammar         <- Spacing (Setting / Definition)+ 
                                                   (EndOfFile /        &{ AppendError("Expected rule or setting") }
                                                   )

Definition      <- Identifier                                           {   With .UserData
                                                                                lNode = .BeginRule(.FindRule(Mid$(ctx.Contents, lOffset, lSize)))
                                                                                If .RuleExpression(lNode) <> 0 Then
                                                                                    ConsoleError "Rule '%1' redefined" & vbCrLf, Mid$(ctx.Contents, lOffset, lSize)
                                                                                End If
                                                                                .Push lNode
                                                                            End With }
                                                                       &{ ClearErrors() And SetUserDataTag($$text) }
                              (Literal                                  { With .UserData: .RuleDescription(.Top) = Mid$(ctx.Contents, lOffset, lSize): End With }
                              )?       Assign 
                                              (Expression               { With .UserData: Dim lNode As Long: lNode = .Pop(): .RuleExpression(.Pop()) = lNode: End With }
                                               /                       &{ AppendError("Invalid definition for rule '" & .UserData.Tag & "'") }
                                              )           SEMI?
Expression      <- Sequence (Choice Sequence                            { With .UserData: lNode = .Pop(): .Push .AppendChild(.MakeAlternate(.Pop), lNode): End With }
                            )*
Sequence        <- Error (Error                                         { With .UserData: lNode = .Pop(): .Push .AppendSequence(.MakeSequence(.Pop), lNode): End With }
                          )*
                 /                                                      { With .UserData: .Push .MakePredicate("1"): End With }
Error           <- Prefix CARET                                        &{ ClearErrors() }
                                (Identifier                             { With .UserData: .Push .AppendChild(.MakeAlternate(.Pop), .MakeErrorReference(Mid$(ctx.Contents, lOffset, lSize))): End With }
                                 / Literal                              { With .UserData: .Push .AppendChild(.MakeAlternate(.Pop), .MakeErrorString(Mid$(ctx.Contents, lOffset, lSize))): End With }
                                 /                                     &{ AppendError("Expected rule or literal for error label") }
                                )
                 / Prefix !CARET
Prefix          <- AND Action                                           { With .UserData: .Push .MakePredicate(Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / AND Variable                                         { With .UserData: .Push .MakePeekFor(.Pop): End With }
                 / NOT Variable                                         { With .UserData: .Push .MakePeekNot(.Pop): End With }
                 /     Variable
Variable        <- Identifier                                           { With .UserData: .Push .MakeVariable(Mid$(ctx.Contents, lOffset, lSize)): End With }
                              COLON Suffix                              { With .UserData: .Push .SetVariable(.Pop, .Pop): End With }
                 / Suffix
Suffix          <- Primary (QUESTION                                    { With .UserData: .Push .MakeQuery(.Pop): End With }
                            / STAR                                      { With .UserData: .Push .MakeStar(.Pop): End With }
                            / PLUS                                      { With .UserData: .Push .MakePlus(.Pop): End With }
                           )?
Primary         <- Identifier !(LiteralNC? Assign)                      { With .UserData: .Push .MakeReference(Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / OPEN                                                &{ ClearErrors() }
                        (Expression CLOSE
                         /                                             &{ AppendError("Invalid expression") }
                        )
                 / Literal                                              { With .UserData: .Push .MakeString(Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / Class                                                { With .UserData: .Push .MakeClass(Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / DOT                                                  { With .UserData: .Push .MakeDot(): End With }
                 / Action                                               { With .UserData: .Push .MakeAction(Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / BEGIN                                                { With .UserData: .Push .MakePredicate("YY_BEGIN"): End With }
                 / END                                                  { With .UserData: .Push .MakePredicate("YY_END"): End With }

Setting         <- SettingName                                          { With .UserData: .Push .MakeString(Mid$(ctx.Contents, lOffset, lSize)): End With }
                                                                       &{ ClearErrors() And SetUserDataTag($$text) }
                               (SettingValue                            { With .UserData: .AppendSetting .Pop, Mid$(ctx.Contents, lOffset, lSize): End With }
                                /                                      &{ AppendError("Invalid value for setting '" & .UserData.Tag & "'") }
                               )
SettingName     <- AT (Identifier / Literal / EMPTY)                   
SettingValue    <- (Identifier / Literal / Action) SEMI?                          
                 
# Lexical syntax

Identifier      <- < IdentStart IdentCont* > Spacing                    { }
IdentStart      <- [a-zA-Z_\-]
IdentCont       <- IdentStart / [0-9]
Literal         <- ['] < (!['] Char )* > ['] Spacing                    { }
                 / ["] < (!["] Char )* > ["] Spacing                    { }
LiteralNC       <- ['] (!['] Char )* ['] Spacing                        # Non-capture version
                 / ["] (!["] Char )* ["] Spacing
Class           <- '[' < (!']' Range)* > ']' Spacing                    { }
Range           <- Char '-' !']' Char / Char
Char            <- '\\' [abefnrtv'"\[\]\\]
                 / '\\' [0-3][0-7][0-7]
                 / '\\' [0-7][0-7]?
                 / '\\' '-'
                 / !'\\' .
LEFTARROW       <- '<-' Spacing
SLASH           <- '/' !'/' Spacing
AND             <- '&' Spacing
NOT             <- '!' Spacing
QUESTION        <- '?' Spacing
STAR            <- '*' Spacing
PLUS            <- '+' Spacing
OPEN            <- '(' Spacing
CLOSE           <- ')' Spacing
DOT             <- '.' Spacing
EMPTY           <- < '' > Spacing                                       { }
Spacing         <- (Space / Comment)*
Comment         <- ('#' / '//') (!EndOfLine .)* EndOfLine
Space           <- ' ' / '\t' / EndOfLine
EndOfLine       <- '\r\n' / '\n' / '\r'
EndOfFile       <- !.

Action          <- '{' EndOfLine* < ([^{}] / ActionNC)* > '}' Spacing   { }
ActionNC        <- '{' ([^{}] / ActionNC)* '}' Spacing                  # Non-capture version
BEGIN           <- '<' Spacing
END             <- '>' Spacing

Assign          <- LEFTARROW / EQUAL
Choice          <- SLASH / BAR
EQUAL           <- '=' Spacing
BAR             <- '|' Spacing
COLON           <- ':' Spacing
SEMI            <- ';' Spacing
AT              <- '@' Spacing
CARET           <- '^' Spacing

@members {
    Errors              As Collection
}

@{
Private Function ClearErrors() As Boolean
    Dim lIdx            As Long
    
    If Not ctx.Errors Is Nothing Then
        For lIdx = ctx.Errors.Count To 1 Step -1
            If ctx.Errors.Item(lIdx)(1) <= ctx.BufPos Then
                ctx.Errors.Remove lIdx
            End If
        Next
        If ctx.Errors.Count = 0 Then
            Set ctx.Errors = Nothing
        End If
    End If
    ClearErrors = True
End Function

Private Function AppendError(sText As String) As Boolean
    If ctx.Errors Is Nothing Then
        Set ctx.Errors = New Collection
    End If
    ctx.Errors.Add Array(sText, ctx.BufPos)
End Function

Private Function SetUserDataTag(sText As String) As Boolean
    ctx.UserData.Tag = sText
    SetUserDataTag = True
End Function

Public Function GetParseErrors() As Collection
    Set GetParseErrors = ctx.Errors
End Function
}