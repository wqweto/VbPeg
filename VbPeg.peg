#
# PE Grammar for PE Grammars
# 
# Adapted from [1] by Ian Piumarta <first-name at last-name point com>.
# Actions translated to VB6 by wqweto@gmail.com.
# 
# Local modifications to support:
#  - VB6 code in '{ ... }' copied verbatim to output as 'semantic action'
#  - input consumed between '<' and '>' is 'Mid$(ctx.Contents, lOffset, lSize)' in semantic actions
# 
# [1] Bryan Ford.  "Parsing Expression Grammars: A Recognition-Based Syntactic
#     Foundation."  Symposium on Principles of Programming Languages,
#     January 14--16, 2004, Venice, Italy.
#

# Hierarchical syntax

Grammar         <- Spacing Definition+ EndOfFile

Definition      <- Identifier                   {
            lNode = .BeginRule(.FindRule(Mid$(ctx.Contents, lOffset, lSize)))
            If .RuleExpression(lNode) <> 0 Then
                ConsoleError "Rule '%1' redefined" & vbCrLf, Mid$(ctx.Contents, lOffset, lSize)
            End If
            .Push lNode
}
                     LEFTARROW Expression       { Dim lNode As Long: lNode = .Pop(): .RuleExpression(.Pop()) = lNode }
Expression      <- Sequence (SLASH Sequence     { lNode = .Pop(): .Push .AppendChild(.MakeAlternate(.Pop), lNode) }
                            )*
Sequence        <- Prefix (Prefix               { lNode = .Pop(): .Push .AppendSequence(.MakeSequence(.Pop), lNode) }
                          )*
                 /                              { .Push .MakePredicate("1") }
Prefix          <- AND Action                   { .Push .MakePredicate(Mid$(ctx.Contents, lOffset, lSize)) }
                 / AND Suffix                   { .Push .MakePeekFor(.Pop) }
                 / NOT Suffix                   { .Push .MakePeekNot(.Pop) }
                 /     Suffix
Suffix          <- Primary (QUESTION            { .Push .MakeQuery(.Pop) }
                             / STAR             { .Push .MakeStar(.Pop) }
                             / PLUS             { .Push .MakePlus(.Pop) }
                           )?
Primary         <- Identifier !LEFTARROW        { .Push .MakeReference(.FindRule(Mid$(ctx.Contents, lOffset, lSize))) }
                 / OPEN Expression CLOSE
                 / Literal                      { .Push .MakeString(Mid$(ctx.Contents, lOffset, lSize)) }
                 / Class                        { .Push .MakeClass(Mid$(ctx.Contents, lOffset, lSize)) }
                 / DOT                          { .Push .MakeDot() }
                 / Action                       { .Push .MakeAction(Mid$(ctx.Contents, lOffset, lSize)) }
                 / BEGIN                        { .Push .MakePredicate("YY_BEGIN") }
                 / END                          { .Push .MakePredicate("YY_END") }

# Lexical syntax

Identifier      <- < IdentStart IdentCont* > Spacing
IdentStart      <- [a-zA-Z_]
IdentCont       <- IdentStart / [0-9]
Literal         <- ['] < (!['] Char )* > ['] Spacing
                 / ["] < (!["] Char )* > ["] Spacing
Class           <- '[' < (!']' Range)* > ']' Spacing
Range           <- Char '-' Char / Char
Char            <- '\\' [abefnrtv'"\[\]\\]
                 / '\\' [0-3][0-7][0-7]
                 / '\\' [0-7][0-7]?
                 / '\\' '-'
                 / !'\\' .
LEFTARROW       <- '<-' Spacing
SLASH           <- '/' Spacing
AND             <- '&' Spacing
NOT             <- '!' Spacing
QUESTION        <- '?' Spacing
STAR            <- '*' Spacing
PLUS            <- '+' Spacing
OPEN            <- '(' Spacing
CLOSE           <- ')' Spacing
DOT             <- '.' Spacing
Spacing         <- (Space / Comment)*
Comment         <- '#' (!EndOfLine .)* EndOfLine
Space           <- ' ' / '\t' / EndOfLine
EndOfLine       <- '\r\n' / '\n' / '\r'
EndOfFile       <- !.

Action          <- '{' < [^}]* > '}' Spacing
BEGIN           <- '<' Spacing
END             <- '>' Spacing
