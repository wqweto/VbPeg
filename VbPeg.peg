#
# PE Grammar for PE Grammars
# 
# Adapted from [1] by Ian Piumarta <first-name at last-name point com>.
# Actions translated to VB6 by wqweto@gmail.com.
# 
# Local modifications to support:
#  - VB6 code in '{ ... }' copied verbatim to output as 'semantic action'
#  - input consumed between '<' and '>' is 'Mid$(ctx.Contents, lOffset, lSize)' in semantic actions
# 
# [1] Bryan Ford.  "Parsing Expression Grammars: A Recognition-Based Syntactic
#     Foundation."  Symposium on Principles of Programming Languages,
#     January 14--16, 2004, Venice, Italy.
#

@trace ConsoleTrace

# Syntax rules

Grammar         <- Spacing (Setting / Rule)+ 
                                             (EndOfFile /              &{ AppendError("Expected rule or setting", ctx.BufPos + 1) }
                                             )

Rule            <- Identifier                                           {   With .UserData
                                                                                lNode = .BeginRule(.FindRule(lOffset, Mid$(ctx.Contents, lOffset, lSize)))
                                                                                If .RuleExpression(lNode) <> 0 Then
                                                                                    AppendError "Rule '" & Mid$(ctx.Contents, lOffset, lSize) & "' redefined", lOffset
                                                                                End If
                                                                                .Push lNode
                                                                            End With }
                                                                       &{ ClearErrors(ctx.BufPos + 1) And SetUserDataTag($$text) }
                              (Literal                                  { With .UserData: .RuleDescription(.Top) = Mid$(ctx.Contents, lOffset, lSize): End With }
                              )?       AssignLiteral 
                                                     (Expression        { With .UserData: lNode = .Pop: .SetExpression .Pop, lNode: End With }
                                                      /                &{ AppendError("Invalid definition for rule '" & .UserData.Tag & "'", ctx.BufPos + 1) }
                                                     )           SEMI?
Expression      <- ChoiceExpr
ChoiceExpr      <- SequenceExpr (ChoiceLiteral SequenceExpr             { With .UserData: lNode = .Pop: .Push .AppendChild(.MakeChoice(lOffset, .Pop), lNode): End With }
                                )*
SequenceExpr    <- ErrorExpr (ErrorExpr                                 { With .UserData: lNode = .Pop: .Push .AppendSequence(.MakeSequence(lOffset, .Pop), lNode): End With }
                             )*
                 /                                                      { With .UserData: .Push .MakePredicate(lOffset, "", AlwaysTrue:=True): End With }
ErrorExpr       <- VariableExpr (CARET                                 &{ ClearErrors(ctx.BufPos + 1) }
                                       (Identifier                      { With .UserData: .Push .AppendChild(.MakeChoice(lOffset, .Pop), .MakeErrorReference(lOffset, Mid$(ctx.Contents, lOffset, lSize))): End With }
                                        / Literal                       { With .UserData: .Push .AppendChild(.MakeChoice(lOffset, .Pop), .MakeErrorString(lOffset, Mid$(ctx.Contents, lOffset, lSize))): End With }
                                        /                              &{ AppendError("Expected rule or literal for error label", ctx.BufPos + 1) }
                                       ))?
VariableExpr    <- Identifier                                           { With .UserData: .Push .MakeVariable(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                              COLON PrefixExpr                          { With .UserData: .Push .SetVariable(lOffset, .Pop, .Pop): End With }
                 / PrefixExpr
PrefixExpr      <- AND CodeBlock                                        { With .UserData: .Push .MakePredicate(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / AND SuffixExpr                                       { With .UserData: .Push .MakePeekFor(lOffset, .Pop): End With }
                 / NOT SuffixExpr                                       { With .UserData: .Push .MakePeekNot(lOffset, .Pop): End With }
                 /     SuffixExpr
SuffixExpr      <- PrimaryExpr (QUESTION                                { With .UserData: .Push .MakeQuery(lOffset, .Pop): End With }
                                / STAR                                  { With .UserData: .Push .MakeStar(lOffset, .Pop): End With }
                                / PLUS                                  { With .UserData: .Push .MakePlus(lOffset, .Pop): End With }
                               )?
PrimaryExpr     <- Identifier !(LiteralNC? AssignLiteral)               { With .UserData: .Push .MakeReference(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / OPEN                                                &{ ClearErrors(ctx.BufPos + 1) }
                        (Expression CLOSE
                         /                                             &{ AppendError("Invalid expression", ctx.BufPos + 1) }
                        )
                 / LiteralNoSpace                                       { With .UserData: .Push .MakeString(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                    (IgnoreCase                                         { With .UserData: .SetIgnoreCase .Top, (Mid$(ctx.Contents, lOffset, lSize) = "i"): End With }
                    )? Spacing
                 / ClassNoSpace                                         { With .UserData: .Push .MakeClass(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                    (IgnoreCase                                         { With .UserData: .SetIgnoreCase .Top, (Mid$(ctx.Contents, lOffset, lSize) = "i"): End With }
                    )? Spacing
                 / DOT                                                  { With .UserData: .Push .MakeDot(lOffset): End With }
                 / CodeBlock                                            { With .UserData: .Push .MakeAction(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                 / BEGIN                                                { With .UserData: .Push .MakePredicate(lOffset, "YY_BEGIN", AlwaysTrue:=True): End With }
                 / END                                                  { With .UserData: .Push .MakePredicate(lOffset, "YY_END", AlwaysTrue:=True): End With }

Setting         <- SettingName                                          { With .UserData: .Push .MakeString(lOffset, Mid$(ctx.Contents, lOffset, lSize)): End With }
                                                                       &{ ClearErrors(ctx.BufPos + 1) And SetUserDataTag($$text) }
                               (SettingValue                            { With .UserData: .SetSettingValue .Pop, Mid$(ctx.Contents, lOffset, lSize): End With }
                                /                                      &{ AppendError("Invalid value for setting '" & .UserData.Tag & "'", ctx.BufPos + 1) }
                               )
SettingName     <- AT (Identifier / Literal / EMPTY)                   
SettingValue    <- (Identifier / Literal / CodeBlock) SEMI?                          
                 
# Lexical rules

Identifier      <- < IdentStart IdentCont* > Spacing                    { }
IdentStart      <- [a-zA-Z_\-]
IdentCont       <- [a-zA-Z_0-9\-]
Literal         <- LiteralNoSpace Spacing
LiteralNoSpace  <- ['] < (!['] Char )* > [']                            { }
                 / ["] < (!["] Char )* > ["]                            { }
LiteralNC       <- ['] (!['] Char )* ['] Spacing                        # Non-capture version
                 / ["] (!["] Char )* ["] Spacing
IgnoreCase      <- < [si] >                                             { }
ClassNoSpace    <- '[' < (!']' Range)* > ']'                            { }
Range           <- Char '-' !']' Char / Char
Char "char"     <- '\\' [abefnrtv'"\[\]\\]
                 / '\\' [0-3][0-7][0-7]
                 / '\\' [0-7][0-7]?
                 / '\\x' [0-9a-fA-F] [0-9a-fA-F]
                 / '\\u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]
                 / '\\' '-'
                 / !'\\' .
LEFTARROW       <- '<-' Spacing
SLASH           <- '/' !'/' Spacing
AND             <- '&' Spacing
NOT             <- '!' Spacing
QUESTION        <- '?' Spacing
STAR            <- '*' Spacing
PLUS            <- '+' Spacing
OPEN            <- '(' Spacing
CLOSE           <- ')' Spacing
DOT             <- '.' Spacing
EMPTY           <- < '' > Spacing                                       { }
Spacing         <- (Space / Comment)*
Comment         <- ('#' / '//') (!EndOfLine .)* EndOfLine
Space           <- ' ' / '\t' / EndOfLine
EndOfLine       <- '\r\n' / '\n' / '\r'
EndOfFile       <- !.

CodeBlock       <- '{' EndOfLine* < ([^{}] / CodeNC)* > '}' Spacing     { }
CodeNC          <- '{' ([^{}] / CodeNC)* '}' Spacing                    # Non-capture version
BEGIN           <- '<' Spacing
END             <- '>' Spacing

AssignLiteral   <- LEFTARROW / EQUAL
ChoiceLiteral   <- SLASH / BAR
EQUAL           <- '=' Spacing
BAR             <- '|' Spacing
COLON           <- ':' Spacing
SEMI            <- ';' Spacing
AT              <- '@' Spacing
CARET           <- '^' Spacing

@members {
    ParseErrors         As Collection
}

@prolog {
    Dim lNode           As Long
    
    With ctx
}

@epilog {
    End With
}

@{
Private Function ClearErrors(ByVal lOffset As Long) As Boolean
    Dim lIdx            As Long
    
    If Not ctx.ParseErrors Is Nothing Then
        For lIdx = ctx.ParseErrors.Count To 1 Step -1
            If ctx.ParseErrors.Item(lIdx)(1) <= lOffset Then
                ctx.ParseErrors.Remove lIdx
            End If
        Next
        If ctx.ParseErrors.Count = 0 Then
            Set ctx.ParseErrors = Nothing
        End If
    End If
    ClearErrors = True
End Function

Private Function AppendError(sText As String, ByVal lOffset As Long) As Boolean
    If ctx.ParseErrors Is Nothing Then
        Set ctx.ParseErrors = New Collection
    End If
    ctx.ParseErrors.Add Array(sText, lOffset)
End Function

Private Function SetUserDataTag(sText As String) As Boolean
    ctx.UserData.Tag = sText
    SetUserDataTag = True
End Function

Public Function GetParseErrors() As Collection
    Set GetParseErrors = ctx.ParseErrors
End Function

Public Function GetContents() As String
    GetContents = ctx.Contents
End Function
}